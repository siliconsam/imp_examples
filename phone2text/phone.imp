%begin

    ! A short piece of IMP code to take in a sequence of ASCII chars (hopefully '2'..'9')
    ! and find ALL strings that can be generated by the old mapping of
    ! telephone digits to a list of alphabet characters, where:-
    ! '2' -> "abc"
    ! '3' -> "def"
    ! '4' -> "ghi"
    ! '5' -> "jkl"
    ! '6' -> "mno"
    ! '7' -> "pqrs"
    ! '8' -> "tuv"
    ! '9' -> "wxyz"

    ! Snippets about the IMP language
    %comment An IMP comment can start with %comment then any sequence of ASCII char upto newline
    !        An IMP comment can also start with !   then any sequence of ASCII char upto newline
    { Another comment style with ASCII text between curly brackets }
    { This comment style can come between source code unlike the %comment or ! styles }
    %comment Beware: the IMP language allows spaces inside a variable identifier
    %comment         that also includes routine names
    ! IMP keywords always start with %
    ! IMP strings can have a maximum of 255 ASCII chars
    ! an IMP %switch is akin to a computed goto
    ! an IMP exception is triggered by the %signal command
    ! an IMP exception is handled by an %on %event ... code block

    %routine depth first search( %string(255) original,node, %string(255) result )
        %integer i
        %string(1) ch
        %switch sw(0:255)  { ass-u-me the node is a sequence of chars but only interested in digits '2'..'9' }
        %string(4) sub node

        ! get the list of values at the given node
        -> sw(charno(node,1))

            ! multiple IMP statements on a line are separated by ;
sw('0'):    sub node = " "; -> esac
sw('1'):    sub node = " "; -> esac
sw('2'):    sub node = "abc"; -> esac
sw('3'):    sub node = "def"; -> esac
sw('4'):    sub node = "ghi"; -> esac
sw('5'):    sub node = "jkl"; -> esac
sw('6'):    sub node = "mno"; -> esac
sw('7'):    sub node = "pqrs"; -> esac
sw('8'):    sub node = "tuv"; -> esac
sw('9'):    sub node = "wxyz"; -> esac
sw(*):      %signal 15, char no(node,1)
esac:

        ! Now, for each node in the current depth
        %for i = 1,1,length(sub node) %cycle
            { eliminate any '0' or '1' digits found in the input node }
            %if (sub node = " ") %start
                ! ignore this sub node
                ch = ""
            %finish %else %start
                ! get the i'th entry in the node list
                ch = to string(char no(sub node,i))
            %finish

            ! Are we at the bottom of the N-ary tree
            %if (length(node) = 1) %start
                ! Yes, so output the result
                ! select input/output indicates which input/output stream
                ! is to read/write data
                select output(0)
                print string( original." -> '".result.ch."'." );new line
                ! As an alternative we could add the tree to a list of results
            %finish %else %start
                ! No, not at the bottom of the N-ary tree
                ! so re-curse down another depth
                depth first search( original, sub string(node,2,length(node)), result.ch)
            %finish
        %repeat
    %end

    %string(255) test number

    ! This is an IMP exception handler
    %on %event 15 %start
        ! Drat an illegal sub node was found
        select output (0)

        print string("Oops! we found '".to string(event_sub)."' in the test number '".test number."'")
        new line
        print string("Only digits 2..9 are valid")
        new line

        { We need to skip to "the end" as there is no cure for this fault }
        -> the end
    %finish

    test number = "23"
    depth first search(test number, test number, "" )

    test number = "079a2"
    depth first search(test number, test number, "" )

the end:
%endofprogram
